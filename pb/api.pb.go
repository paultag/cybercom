// Code generated by protoc-gen-go.
// source: api.proto
// DO NOT EDIT!

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	api.proto
	primitives.proto

It has these top-level messages:
	Empty
	Id
	Serial
	Entity
	Configuration
	CSR
	Certificate
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Entity_State int32

const (
	Entity_UNKNOWN  Entity_State = 0
	Entity_PENDING  Entity_State = 1
	Entity_APPROVED Entity_State = 2
	Entity_REJECTED Entity_State = 3
	Entity_REVOKED  Entity_State = 4
	Entity_ONEOFF   Entity_State = 5
)

var Entity_State_name = map[int32]string{
	0: "UNKNOWN",
	1: "PENDING",
	2: "APPROVED",
	3: "REJECTED",
	4: "REVOKED",
	5: "ONEOFF",
}
var Entity_State_value = map[string]int32{
	"UNKNOWN":  0,
	"PENDING":  1,
	"APPROVED": 2,
	"REJECTED": 3,
	"REVOKED":  4,
	"ONEOFF":   5,
}

func (x Entity_State) String() string {
	return proto.EnumName(Entity_State_name, int32(x))
}
func (Entity_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Id struct {
	Id []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Id) Reset()                    { *m = Id{} }
func (m *Id) String() string            { return proto.CompactTextString(m) }
func (*Id) ProtoMessage()               {}
func (*Id) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Id) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

type Serial struct {
	Serial []byte `protobuf:"bytes,1,opt,name=serial,proto3" json:"serial,omitempty"`
}

func (m *Serial) Reset()                    { *m = Serial{} }
func (m *Serial) String() string            { return proto.CompactTextString(m) }
func (*Serial) ProtoMessage()               {}
func (*Serial) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Serial) GetSerial() []byte {
	if m != nil {
		return m.Serial
	}
	return nil
}

type Entity struct {
	Id        *Id          `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	State     Entity_State `protobuf:"varint,2,opt,name=state,enum=cybercom.Entity_State" json:"state,omitempty"`
	Csr       *CSR         `protobuf:"bytes,3,opt,name=csr" json:"csr,omitempty"`
	Email     string       `protobuf:"bytes,4,opt,name=email" json:"email,omitempty"`
	Longevity string       `protobuf:"bytes,5,opt,name=longevity" json:"longevity,omitempty"`
	Expires   uint64       `protobuf:"varint,6,opt,name=expires" json:"expires,omitempty"`
}

func (m *Entity) Reset()                    { *m = Entity{} }
func (m *Entity) String() string            { return proto.CompactTextString(m) }
func (*Entity) ProtoMessage()               {}
func (*Entity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Entity) GetId() *Id {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Entity) GetState() Entity_State {
	if m != nil {
		return m.State
	}
	return Entity_UNKNOWN
}

func (m *Entity) GetCsr() *CSR {
	if m != nil {
		return m.Csr
	}
	return nil
}

func (m *Entity) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *Entity) GetLongevity() string {
	if m != nil {
		return m.Longevity
	}
	return ""
}

func (m *Entity) GetExpires() uint64 {
	if m != nil {
		return m.Expires
	}
	return 0
}

type Configuration struct {
	// something like "Paul's Home CA" or "StrexCorp Synernists, Inc."
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Default template to use for clients that don't know any better
	// than this. It's assumed a user is a part of the CYBERCOM server that
	// belongs (or holds a role) to an organization. As such, we can inheret
	// their configuration.
	RequestTemplate *Configuration_RequestTemplate `protobuf:"bytes,2,opt,name=request_template,json=requestTemplate" json:"request_template,omitempty"`
	// the set of CAs we should know about. Natch, we already need the CA
	// this server was signed with in order to get his pool, but this could
	// be great for getting the full set of operational CAs we know about.
	Ca []*Certificate `protobuf:"bytes,3,rep,name=ca" json:"ca,omitempty"`
	// Get the client's certificate back if provided
	Peer *Certificate `protobuf:"bytes,4,opt,name=peer" json:"peer,omitempty"`
	// Get the client's entiy entry if provided
	Entity *Entity `protobuf:"bytes,5,opt,name=entity" json:"entity,omitempty"`
}

func (m *Configuration) Reset()                    { *m = Configuration{} }
func (m *Configuration) String() string            { return proto.CompactTextString(m) }
func (*Configuration) ProtoMessage()               {}
func (*Configuration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Configuration) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Configuration) GetRequestTemplate() *Configuration_RequestTemplate {
	if m != nil {
		return m.RequestTemplate
	}
	return nil
}

func (m *Configuration) GetCa() []*Certificate {
	if m != nil {
		return m.Ca
	}
	return nil
}

func (m *Configuration) GetPeer() *Certificate {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Configuration) GetEntity() *Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

type Configuration_RequestTemplate struct {
	Country            string `protobuf:"bytes,1,opt,name=country" json:"country,omitempty"`
	Organization       string `protobuf:"bytes,2,opt,name=organization" json:"organization,omitempty"`
	OrganizationalUnit string `protobuf:"bytes,3,opt,name=organizational_unit,json=organizationalUnit" json:"organizational_unit,omitempty"`
	Locality           string `protobuf:"bytes,4,opt,name=locality" json:"locality,omitempty"`
	Province           string `protobuf:"bytes,5,opt,name=province" json:"province,omitempty"`
}

func (m *Configuration_RequestTemplate) Reset()         { *m = Configuration_RequestTemplate{} }
func (m *Configuration_RequestTemplate) String() string { return proto.CompactTextString(m) }
func (*Configuration_RequestTemplate) ProtoMessage()    {}
func (*Configuration_RequestTemplate) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0}
}

func (m *Configuration_RequestTemplate) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *Configuration_RequestTemplate) GetOrganization() string {
	if m != nil {
		return m.Organization
	}
	return ""
}

func (m *Configuration_RequestTemplate) GetOrganizationalUnit() string {
	if m != nil {
		return m.OrganizationalUnit
	}
	return ""
}

func (m *Configuration_RequestTemplate) GetLocality() string {
	if m != nil {
		return m.Locality
	}
	return ""
}

func (m *Configuration_RequestTemplate) GetProvince() string {
	if m != nil {
		return m.Province
	}
	return ""
}

func init() {
	proto.RegisterType((*Empty)(nil), "cybercom.Empty")
	proto.RegisterType((*Id)(nil), "cybercom.Id")
	proto.RegisterType((*Serial)(nil), "cybercom.Serial")
	proto.RegisterType((*Entity)(nil), "cybercom.Entity")
	proto.RegisterType((*Configuration)(nil), "cybercom.Configuration")
	proto.RegisterType((*Configuration_RequestTemplate)(nil), "cybercom.Configuration.RequestTemplate")
	proto.RegisterEnum("cybercom.Entity_State", Entity_State_name, Entity_State_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Cybercom service

type CybercomClient interface {
	// Get a Cybercom configuration
	GetConfiguration(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Configuration, error)
	// Submimt a CSR for processing later, returning the Entity ID
	// that the management layer will use as well.
	Register(ctx context.Context, in *CSR, opts ...grpc.CallOption) (*Entity, error)
	// Get an entity and their information based on their Entity ID
	GetEntity(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Entity, error)
	// Given an Entity ID, return a stream of Certificates which have
	// been issued to that client.
	GetCertificates(ctx context.Context, in *Id, opts ...grpc.CallOption) (Cybercom_GetCertificatesClient, error)
	// Given an Entity ID, return the current Certificate for the
	// user.
	GetCertificate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Certificate, error)
	// Given a Serial, return the Certifciate that was issued
	GetCertificateBySerial(ctx context.Context, in *Serial, opts ...grpc.CallOption) (*Certificate, error)
	// Get the Entity for the given Certificate by its Serial
	GetEntityBySerial(ctx context.Context, in *Serial, opts ...grpc.CallOption) (*Entity, error)
	// Get a new Certificate for the client on the other end of the TLS
	// connection. If a Certificate is valid, and the Entity is valid, this
	// will trigger a new Certificate to be issued.
	Renew(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Certificate, error)
	// Get all entities known to the system.
	GetEntities(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Cybercom_GetEntitiesClient, error)
	// Issue Certificate for an Entity.
	IssueCertificate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Certificate, error)
	SetEntityState(ctx context.Context, in *Entity, opts ...grpc.CallOption) (*Entity, error)
	SetEntityLongevity(ctx context.Context, in *Entity, opts ...grpc.CallOption) (*Entity, error)
	SetEntityExpiry(ctx context.Context, in *Entity, opts ...grpc.CallOption) (*Entity, error)
}

type cybercomClient struct {
	cc *grpc.ClientConn
}

func NewCybercomClient(cc *grpc.ClientConn) CybercomClient {
	return &cybercomClient{cc}
}

func (c *cybercomClient) GetConfiguration(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Configuration, error) {
	out := new(Configuration)
	err := grpc.Invoke(ctx, "/cybercom.Cybercom/GetConfiguration", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cybercomClient) Register(ctx context.Context, in *CSR, opts ...grpc.CallOption) (*Entity, error) {
	out := new(Entity)
	err := grpc.Invoke(ctx, "/cybercom.Cybercom/Register", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cybercomClient) GetEntity(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Entity, error) {
	out := new(Entity)
	err := grpc.Invoke(ctx, "/cybercom.Cybercom/GetEntity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cybercomClient) GetCertificates(ctx context.Context, in *Id, opts ...grpc.CallOption) (Cybercom_GetCertificatesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Cybercom_serviceDesc.Streams[0], c.cc, "/cybercom.Cybercom/GetCertificates", opts...)
	if err != nil {
		return nil, err
	}
	x := &cybercomGetCertificatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Cybercom_GetCertificatesClient interface {
	Recv() (*Certificate, error)
	grpc.ClientStream
}

type cybercomGetCertificatesClient struct {
	grpc.ClientStream
}

func (x *cybercomGetCertificatesClient) Recv() (*Certificate, error) {
	m := new(Certificate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cybercomClient) GetCertificate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Certificate, error) {
	out := new(Certificate)
	err := grpc.Invoke(ctx, "/cybercom.Cybercom/GetCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cybercomClient) GetCertificateBySerial(ctx context.Context, in *Serial, opts ...grpc.CallOption) (*Certificate, error) {
	out := new(Certificate)
	err := grpc.Invoke(ctx, "/cybercom.Cybercom/GetCertificateBySerial", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cybercomClient) GetEntityBySerial(ctx context.Context, in *Serial, opts ...grpc.CallOption) (*Entity, error) {
	out := new(Entity)
	err := grpc.Invoke(ctx, "/cybercom.Cybercom/GetEntityBySerial", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cybercomClient) Renew(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Certificate, error) {
	out := new(Certificate)
	err := grpc.Invoke(ctx, "/cybercom.Cybercom/Renew", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cybercomClient) GetEntities(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Cybercom_GetEntitiesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Cybercom_serviceDesc.Streams[1], c.cc, "/cybercom.Cybercom/GetEntities", opts...)
	if err != nil {
		return nil, err
	}
	x := &cybercomGetEntitiesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Cybercom_GetEntitiesClient interface {
	Recv() (*Entity, error)
	grpc.ClientStream
}

type cybercomGetEntitiesClient struct {
	grpc.ClientStream
}

func (x *cybercomGetEntitiesClient) Recv() (*Entity, error) {
	m := new(Entity)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cybercomClient) IssueCertificate(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Certificate, error) {
	out := new(Certificate)
	err := grpc.Invoke(ctx, "/cybercom.Cybercom/IssueCertificate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cybercomClient) SetEntityState(ctx context.Context, in *Entity, opts ...grpc.CallOption) (*Entity, error) {
	out := new(Entity)
	err := grpc.Invoke(ctx, "/cybercom.Cybercom/SetEntityState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cybercomClient) SetEntityLongevity(ctx context.Context, in *Entity, opts ...grpc.CallOption) (*Entity, error) {
	out := new(Entity)
	err := grpc.Invoke(ctx, "/cybercom.Cybercom/SetEntityLongevity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cybercomClient) SetEntityExpiry(ctx context.Context, in *Entity, opts ...grpc.CallOption) (*Entity, error) {
	out := new(Entity)
	err := grpc.Invoke(ctx, "/cybercom.Cybercom/SetEntityExpiry", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Cybercom service

type CybercomServer interface {
	// Get a Cybercom configuration
	GetConfiguration(context.Context, *Empty) (*Configuration, error)
	// Submimt a CSR for processing later, returning the Entity ID
	// that the management layer will use as well.
	Register(context.Context, *CSR) (*Entity, error)
	// Get an entity and their information based on their Entity ID
	GetEntity(context.Context, *Id) (*Entity, error)
	// Given an Entity ID, return a stream of Certificates which have
	// been issued to that client.
	GetCertificates(*Id, Cybercom_GetCertificatesServer) error
	// Given an Entity ID, return the current Certificate for the
	// user.
	GetCertificate(context.Context, *Id) (*Certificate, error)
	// Given a Serial, return the Certifciate that was issued
	GetCertificateBySerial(context.Context, *Serial) (*Certificate, error)
	// Get the Entity for the given Certificate by its Serial
	GetEntityBySerial(context.Context, *Serial) (*Entity, error)
	// Get a new Certificate for the client on the other end of the TLS
	// connection. If a Certificate is valid, and the Entity is valid, this
	// will trigger a new Certificate to be issued.
	Renew(context.Context, *Empty) (*Certificate, error)
	// Get all entities known to the system.
	GetEntities(*Empty, Cybercom_GetEntitiesServer) error
	// Issue Certificate for an Entity.
	IssueCertificate(context.Context, *Id) (*Certificate, error)
	SetEntityState(context.Context, *Entity) (*Entity, error)
	SetEntityLongevity(context.Context, *Entity) (*Entity, error)
	SetEntityExpiry(context.Context, *Entity) (*Entity, error)
}

func RegisterCybercomServer(s *grpc.Server, srv CybercomServer) {
	s.RegisterService(&_Cybercom_serviceDesc, srv)
}

func _Cybercom_GetConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CybercomServer).GetConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cybercom.Cybercom/GetConfiguration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CybercomServer).GetConfiguration(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cybercom_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CSR)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CybercomServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cybercom.Cybercom/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CybercomServer).Register(ctx, req.(*CSR))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cybercom_GetEntity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CybercomServer).GetEntity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cybercom.Cybercom/GetEntity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CybercomServer).GetEntity(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cybercom_GetCertificates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Id)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CybercomServer).GetCertificates(m, &cybercomGetCertificatesServer{stream})
}

type Cybercom_GetCertificatesServer interface {
	Send(*Certificate) error
	grpc.ServerStream
}

type cybercomGetCertificatesServer struct {
	grpc.ServerStream
}

func (x *cybercomGetCertificatesServer) Send(m *Certificate) error {
	return x.ServerStream.SendMsg(m)
}

func _Cybercom_GetCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CybercomServer).GetCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cybercom.Cybercom/GetCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CybercomServer).GetCertificate(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cybercom_GetCertificateBySerial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Serial)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CybercomServer).GetCertificateBySerial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cybercom.Cybercom/GetCertificateBySerial",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CybercomServer).GetCertificateBySerial(ctx, req.(*Serial))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cybercom_GetEntityBySerial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Serial)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CybercomServer).GetEntityBySerial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cybercom.Cybercom/GetEntityBySerial",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CybercomServer).GetEntityBySerial(ctx, req.(*Serial))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cybercom_Renew_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CybercomServer).Renew(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cybercom.Cybercom/Renew",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CybercomServer).Renew(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cybercom_GetEntities_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CybercomServer).GetEntities(m, &cybercomGetEntitiesServer{stream})
}

type Cybercom_GetEntitiesServer interface {
	Send(*Entity) error
	grpc.ServerStream
}

type cybercomGetEntitiesServer struct {
	grpc.ServerStream
}

func (x *cybercomGetEntitiesServer) Send(m *Entity) error {
	return x.ServerStream.SendMsg(m)
}

func _Cybercom_IssueCertificate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CybercomServer).IssueCertificate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cybercom.Cybercom/IssueCertificate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CybercomServer).IssueCertificate(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cybercom_SetEntityState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Entity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CybercomServer).SetEntityState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cybercom.Cybercom/SetEntityState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CybercomServer).SetEntityState(ctx, req.(*Entity))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cybercom_SetEntityLongevity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Entity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CybercomServer).SetEntityLongevity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cybercom.Cybercom/SetEntityLongevity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CybercomServer).SetEntityLongevity(ctx, req.(*Entity))
	}
	return interceptor(ctx, in, info, handler)
}

func _Cybercom_SetEntityExpiry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Entity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CybercomServer).SetEntityExpiry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cybercom.Cybercom/SetEntityExpiry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CybercomServer).SetEntityExpiry(ctx, req.(*Entity))
	}
	return interceptor(ctx, in, info, handler)
}

var _Cybercom_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cybercom.Cybercom",
	HandlerType: (*CybercomServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConfiguration",
			Handler:    _Cybercom_GetConfiguration_Handler,
		},
		{
			MethodName: "Register",
			Handler:    _Cybercom_Register_Handler,
		},
		{
			MethodName: "GetEntity",
			Handler:    _Cybercom_GetEntity_Handler,
		},
		{
			MethodName: "GetCertificate",
			Handler:    _Cybercom_GetCertificate_Handler,
		},
		{
			MethodName: "GetCertificateBySerial",
			Handler:    _Cybercom_GetCertificateBySerial_Handler,
		},
		{
			MethodName: "GetEntityBySerial",
			Handler:    _Cybercom_GetEntityBySerial_Handler,
		},
		{
			MethodName: "Renew",
			Handler:    _Cybercom_Renew_Handler,
		},
		{
			MethodName: "IssueCertificate",
			Handler:    _Cybercom_IssueCertificate_Handler,
		},
		{
			MethodName: "SetEntityState",
			Handler:    _Cybercom_SetEntityState_Handler,
		},
		{
			MethodName: "SetEntityLongevity",
			Handler:    _Cybercom_SetEntityLongevity_Handler,
		},
		{
			MethodName: "SetEntityExpiry",
			Handler:    _Cybercom_SetEntityExpiry_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetCertificates",
			Handler:       _Cybercom_GetCertificates_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetEntities",
			Handler:       _Cybercom_GetEntities_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}

func init() { proto.RegisterFile("api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 685 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x55, 0xd1, 0x6e, 0xda, 0x4a,
	0x10, 0x8d, 0x0d, 0x26, 0x30, 0x10, 0xf0, 0x9d, 0x9b, 0x9b, 0x6b, 0xa1, 0x48, 0x17, 0x59, 0xba,
	0x2a, 0x95, 0x5a, 0x9a, 0xd2, 0xaa, 0x51, 0xfa, 0x50, 0xa9, 0x01, 0x27, 0xa2, 0xa9, 0x20, 0x5a,
	0x92, 0x54, 0xea, 0x4b, 0xe4, 0x98, 0x0d, 0x5a, 0xc9, 0xd8, 0xee, 0x7a, 0x49, 0x4b, 0x7f, 0xa5,
	0xff, 0xd0, 0xe7, 0x7e, 0x55, 0xbf, 0xa1, 0xf2, 0xda, 0x18, 0x1c, 0xa0, 0x8a, 0xfa, 0xe6, 0xb3,
	0x73, 0xce, 0xcc, 0x9e, 0x99, 0xdd, 0x35, 0x94, 0xec, 0x80, 0xb5, 0x02, 0xee, 0x0b, 0x1f, 0x8b,
	0xce, 0xec, 0x86, 0x72, 0xc7, 0x9f, 0xd4, 0xf5, 0x80, 0xb3, 0x09, 0x13, 0xec, 0x8e, 0x86, 0x71,
	0xcc, 0xdc, 0x06, 0xcd, 0x9a, 0x04, 0x62, 0x66, 0xee, 0x82, 0xda, 0x1b, 0x61, 0x15, 0x54, 0x36,
	0x32, 0x94, 0x86, 0xd2, 0xac, 0x10, 0x95, 0x8d, 0xcc, 0x06, 0x14, 0x86, 0x94, 0x33, 0xdb, 0xc5,
	0x3d, 0x28, 0x84, 0xf2, 0x2b, 0x89, 0x26, 0xc8, 0xfc, 0xa6, 0x42, 0xc1, 0xf2, 0x04, 0x13, 0x33,
	0xdc, 0x4f, 0xc5, 0xe5, 0x76, 0xa5, 0x35, 0x2f, 0xda, 0xea, 0x8d, 0xa2, 0x54, 0xf8, 0x04, 0xb4,
	0x50, 0xd8, 0x82, 0x1a, 0x6a, 0x43, 0x69, 0x56, 0xdb, 0x7b, 0x0b, 0x42, 0x2c, 0x6f, 0x0d, 0xa3,
	0x28, 0x89, 0x49, 0xf8, 0x1f, 0xe4, 0x9c, 0x90, 0x1b, 0x39, 0x99, 0x6c, 0x67, 0xc1, 0xed, 0x0c,
	0x09, 0x89, 0x22, 0xb8, 0x0b, 0x1a, 0x9d, 0xd8, 0xcc, 0x35, 0xf2, 0x0d, 0xa5, 0x59, 0x22, 0x31,
	0xc0, 0x7d, 0x28, 0xb9, 0xbe, 0x37, 0xa6, 0x77, 0x4c, 0xcc, 0x0c, 0x4d, 0x46, 0x16, 0x0b, 0x68,
	0xc0, 0x36, 0xfd, 0x12, 0x30, 0x4e, 0x43, 0xa3, 0xd0, 0x50, 0x9a, 0x79, 0x32, 0x87, 0xe6, 0x15,
	0x68, 0xb2, 0x3c, 0x96, 0x61, 0xfb, 0xb2, 0x7f, 0xd6, 0x1f, 0x7c, 0xe8, 0xeb, 0x5b, 0x11, 0x38,
	0xb7, 0xfa, 0xdd, 0x5e, 0xff, 0x54, 0x57, 0xb0, 0x02, 0xc5, 0xb7, 0xe7, 0xe7, 0x64, 0x70, 0x65,
	0x75, 0x75, 0x35, 0x42, 0xc4, 0x7a, 0x67, 0x75, 0x2e, 0xac, 0xae, 0x9e, 0x8b, 0x88, 0xc4, 0xba,
	0x1a, 0x9c, 0x59, 0x5d, 0x3d, 0x8f, 0x00, 0x85, 0x41, 0xdf, 0x1a, 0x9c, 0x9c, 0xe8, 0x9a, 0xf9,
	0x3d, 0x07, 0x3b, 0x1d, 0xdf, 0xbb, 0x65, 0xe3, 0x29, 0xb7, 0x05, 0xf3, 0x3d, 0x44, 0xc8, 0x7b,
	0xf6, 0x84, 0xca, 0x36, 0x95, 0x88, 0xfc, 0x46, 0x02, 0x3a, 0xa7, 0x9f, 0xa6, 0x34, 0x14, 0xd7,
	0x82, 0x4e, 0x02, 0x77, 0xde, 0xa5, 0x72, 0xfb, 0xd1, 0x92, 0xf3, 0xe5, 0x34, 0x2d, 0x12, 0xf3,
	0x2f, 0x12, 0x3a, 0xa9, 0xf1, 0xec, 0x02, 0xfe, 0x0f, 0xaa, 0x63, 0x1b, 0xb9, 0x46, 0xae, 0x59,
	0x6e, 0xff, 0xb3, 0x94, 0x85, 0x72, 0xc1, 0x6e, 0x99, 0x13, 0x69, 0x54, 0xc7, 0xc6, 0xc7, 0x90,
	0x0f, 0x28, 0xe5, 0xb2, 0x8b, 0x1b, 0x89, 0x92, 0x82, 0x4d, 0x28, 0x50, 0x39, 0x29, 0xd9, 0xd8,
	0x72, 0x5b, 0xbf, 0x3f, 0x41, 0x92, 0xc4, 0xeb, 0x3f, 0x14, 0xa8, 0xdd, 0xdb, 0x60, 0xd4, 0x7b,
	0xc7, 0x9f, 0x7a, 0x82, 0xcf, 0x12, 0xeb, 0x73, 0x88, 0x26, 0x54, 0x7c, 0x3e, 0xb6, 0x3d, 0xf6,
	0x55, 0x5a, 0x93, 0xce, 0x4b, 0x24, 0xb3, 0x86, 0xcf, 0xe0, 0xef, 0x65, 0x6c, 0xbb, 0xd7, 0x53,
	0x8f, 0x09, 0x79, 0x3c, 0x4a, 0x04, 0xb3, 0xa1, 0x4b, 0x8f, 0x09, 0xac, 0x43, 0xd1, 0xf5, 0x1d,
	0xdb, 0x8d, 0xb6, 0x1b, 0x9f, 0x90, 0x14, 0x47, 0xb1, 0x80, 0xfb, 0x77, 0xcc, 0x73, 0x68, 0x72,
	0x46, 0x52, 0xdc, 0xfe, 0xa9, 0x41, 0xb1, 0x93, 0xd8, 0xc2, 0x37, 0xa0, 0x9f, 0x52, 0x91, 0x9d,
	0x5f, 0x6d, 0xc9, 0x75, 0x74, 0x71, 0xea, 0xff, 0x6e, 0x18, 0x91, 0xb9, 0x85, 0x4f, 0xa1, 0x48,
	0xe8, 0x98, 0x85, 0x82, 0x72, 0xcc, 0x9e, 0xe1, 0xfa, 0x4a, 0xf3, 0x24, 0xbd, 0x74, 0x4a, 0x45,
	0x72, 0x99, 0x32, 0x17, 0x68, 0x2d, 0xfd, 0x35, 0xd4, 0xa2, 0xdd, 0x2d, 0xe6, 0x14, 0xde, 0x13,
	0xad, 0x9f, 0xa6, 0xb9, 0x75, 0xa0, 0xe0, 0x21, 0x54, 0xb3, 0xda, 0x07, 0x4a, 0xb1, 0x03, 0x7b,
	0x59, 0xe1, 0xf1, 0x2c, 0x79, 0x20, 0x96, 0xb6, 0x18, 0xaf, 0x6c, 0x4e, 0x72, 0x04, 0x7f, 0xa5,
	0x46, 0x7f, 0xa3, 0x5f, 0x67, 0xfa, 0x39, 0x68, 0x84, 0x7a, 0xf4, 0xf3, 0xea, 0x1c, 0x36, 0x56,
	0x7b, 0x09, 0xe5, 0x79, 0x35, 0x46, 0xc3, 0x55, 0xe1, 0x9a, 0x32, 0x07, 0x0a, 0x1e, 0x81, 0xde,
	0x0b, 0xc3, 0x29, 0xfd, 0x83, 0x1e, 0xbd, 0x82, 0xea, 0x70, 0x6e, 0x2f, 0x7e, 0x55, 0x56, 0x4a,
	0x6c, 0x18, 0x28, 0xa6, 0xba, 0xf7, 0xe9, 0xa3, 0xf5, 0x30, 0xed, 0x21, 0xd4, 0x52, 0xad, 0x15,
	0x3d, 0x6a, 0x0f, 0x14, 0x1e, 0xe7, 0x3f, 0xaa, 0xc1, 0xcd, 0x4d, 0x41, 0xfe, 0x0d, 0x5e, 0xfc,
	0x0a, 0x00, 0x00, 0xff, 0xff, 0xd7, 0x65, 0xb5, 0x5c, 0x36, 0x06, 0x00, 0x00,
}
